"use strict";function _instanceof(e,t){return null!=t&&"undefined"!=typeof Symbol&&t[Symbol.hasInstance]?!!t[Symbol.hasInstance](e):e instanceof t}function _typeof(e){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function _classCallCheck(e,t){if(!_instanceof(e,t))throw new TypeError("Cannot call a class as a function")}function _defineProperties(e,t){for(var r=0;r<t.length;r++){var o=t[r];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}function _createClass(e,t,r){return t&&_defineProperties(e.prototype,t),r&&_defineProperties(e,r),e}var cryptoLib=window.crypto||window.msCrypto,cryptoApi=cryptoLib.subtle||cryptoLib.webkitSubtle,chars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",lookup=new Uint8Array(256),PBES2_OID="06092a864886f70d01050d",PBKDF2_OID="06092a864886f70d01050c",AES256GCM_OID="060960864801650304012e",AES192GCM_OID="060960864801650304011a",AES128GCM_OID="0609608648016503040106",AES256CBC_OID="060960864801650304012a",AES192CBC_OID="0609608648016503040116",AES128CBC_OID="0609608648016503040102",AES256CFB_OID="060960864801650304012c",AES192CFB_OID="0609608648016503040118",AES128CFB_OID="06086086480165030404",SHA512_OID="06082a864886f70d020b0500",SHA384_OID="06082a864886f70d020a0500",SHA256_OID="06082a864886f70d02090500",SHA1_OID="06082a864886f70d02070500",RSA_OID="06092a864886f70d010101",EC_OID="06072a8648ce3d0201",P256_OID="06082a8648ce3d030107",P384_OID="06052b81040022",P521_OID="06052b81040023",OpenCrypto=function(){function t(){_classCallCheck(this,t);for(var e=0;e<chars.length;e++)lookup[chars.charCodeAt(e)]=e}return _createClass(t,[{key:"encodeAb",value:function(e){for(var t=new Uint8Array(e),r=t.length,o="",n=0;n<r;n+=3)o+=chars[t[n]>>2],o+=chars[(3&t[n])<<4|t[n+1]>>4],o+=chars[(15&t[n+1])<<2|t[n+2]>>6],o+=chars[63&t[n+2]];return r%3==2?o=o.substring(0,o.length-1)+"=":r%3==1&&(o=o.substring(0,o.length-2)+"=="),o}},{key:"decodeAb",value:function(e){var t,r,o,n,a=e.length,i=.75*e.length,p=0;"="===e[e.length-1]&&(i--,"="===e[e.length-2]&&i--);for(var s=new ArrayBuffer(i),c=new Uint8Array(s),f=0;f<a;f+=4)t=lookup[e.charCodeAt(f)],r=lookup[e.charCodeAt(f+1)],o=lookup[e.charCodeAt(f+2)],n=lookup[e.charCodeAt(f+3)],c[p++]=t<<2|r>>4,c[p++]=(15&r)<<4|o>>2,c[p++]=(3&o)<<6|63&n;return s}},{key:"arrayBufferToString",value:function(e){if("object"!==_typeof(e))throw new TypeError("Expected input of arrayBuffer to be an ArrayBuffer Object");return new TextDecoder("utf-8").decode(e)}},{key:"stringToArrayBuffer",value:function(e){if("string"!=typeof e)throw new TypeError("Expected input of str to be a String");return new TextEncoder("utf-8").encode(e).buffer}},{key:"arrayBufferToHexString",value:function(e){if("object"!==_typeof(e))throw new TypeError("Expected input of arrayBuffer to be an ArrayBuffer Object");for(var t,r=new Uint8Array(e),o="",n=0;n<r.byteLength;n++)(t=r[n].toString(16)).length<2&&(t="0"+t),o+=t;return o}},{key:"hexStringToArrayBuffer",value:function(e){if("string"!=typeof e)throw new TypeError("Expected input of hexString to be a String");if(e.length%2!=0)throw new RangeError("Expected string to be an even number of characters");for(var t=new Uint8Array(e.length/2),r=0;r<e.length;r+=2)t[r/2]=parseInt(e.substring(r,r+2),16);return t.buffer}},{key:"arrayBufferToBase64",value:function(e){if("object"!==_typeof(e))throw new TypeError("Expected input of arrayBuffer to be an ArrayBuffer Object");return this.encodeAb(e)}},{key:"base64ToArrayBuffer",value:function(e){if("string"!=typeof e)throw new TypeError("Expected input of b64 to be a Base64 String");return this.decodeAb(e)}},{key:"decimalToHex",value:function(e,t){if("boolean"!=typeof(t=void 0!==t&&t))throw new TypeError("Expected input of unsigned to be a Boolean");var r=null;if("number"==typeof e)return t?(r=e.toString(16)).length%2?"000"+r:"00"+r:(r=e.toString(16)).length%2?"0"+r:r;if("string"==typeof e)return(r=(e.length/2).toString(16)).length%2?"0"+r:r;throw new TypeError("Expected input of d to be a Number or String")}},{key:"addNewLines",value:function(e){for(var t="";0<e.length;)t+=e.substring(0,64)+"\r\n",e=e.substring(64);return t}},{key:"removeLines",value:function(e){return e.replace(/\r?\n|\r/g,"")}},{key:"toAsn1",value:function(e,t,r,o,n,a,i){e=this.arrayBufferToHexString(e),t=this.arrayBufferToHexString(t),r=this.arrayBufferToHexString(r),o=this.decimalToHex(o,!0);var p={};switch(n){case"SHA-512":p.HASH_OID=SHA512_OID;break;case"SHA-384":p.HASH_OID=SHA384_OID;break;case"SHA-256":p.HASH_OID=SHA256_OID;break;case"SHA-1":p.HASH_OID=SHA1_OID}switch(a){case"AES-GCM":256===i?p.CIPHER_OID=AES256GCM_OID:192===i?p.CIPHER_OID=AES192GCM_OID:128===i&&(p.CIPHER_OID=AES128GCM_OID);break;case"AES-CBC":256===i?p.CIPHER_OID=AES256CBC_OID:192===i?p.CIPHER_OID=AES192CBC_OID:128===i&&(p.CIPHER_OID=AES128CBC_OID);break;case"AES-CFB":256===i?p.CIPHER_OID=AES256CFB_OID:192===i?p.CIPHER_OID=AES192CFB_OID:128===i&&(p.CIPHER_OID=AES128CFB_OID)}var s="02"+this.decimalToHex(o.length/2)+o,c="04"+this.decimalToHex(t)+t,f="04"+this.decimalToHex(r)+r,y="04"+(this.decimalToHex(e).length/2==2?"82":"81")+this.decimalToHex(e)+e;p.SEQUENCE_AES_CONTAINER="30"+this.decimalToHex(p.CIPHER_OID+f),p.SEQUENCE_HASH_CONTAINER="30"+this.decimalToHex(p.HASH_OID),p.SEQUENCE_PBKDF2_INNER_CONTAINER="30"+this.decimalToHex(c+s+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID),p.SEQUENCE_PBKDF2_CONTAINER="30"+this.decimalToHex(PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+c+s+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID),p.SEQUENCE_PBES2_INNER_CONTAINER="30"+this.decimalToHex(p.SEQUENCE_PBKDF2_CONTAINER+PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+c+s+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID+p.SEQUENCE_AES_CONTAINER+p.CIPHER_OID+f),p.SEQUENCE_PBES2_CONTAINER="30"+this.decimalToHex(PBES2_OID+p.SEQUENCE_PBES2_INNER_CONTAINER+p.SEQUENCE_PBKDF2_CONTAINER+PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+c+s+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID+p.SEQUENCE_AES_CONTAINER+p.CIPHER_OID+f);var u=p.SEQUENCE_PBES2_CONTAINER+PBES2_OID+p.SEQUENCE_PBES2_INNER_CONTAINER+p.SEQUENCE_PBKDF2_CONTAINER+PBKDF2_OID+p.SEQUENCE_PBKDF2_INNER_CONTAINER+c+s+p.SEQUENCE_HASH_CONTAINER+p.HASH_OID+p.SEQUENCE_AES_CONTAINER+p.CIPHER_OID+f,h=this.decimalToHex(u+y),E="30"+(h.length/2==2?"82":"81")+h+u+y,d=this.hexStringToArrayBuffer(E),g=this.arrayBufferToBase64(d);return g="-----BEGIN ENCRYPTED PRIVATE KEY-----\r\n"+(g=this.addNewLines(g))+"-----END ENCRYPTED PRIVATE KEY-----"}},{key:"fromAsn1",value:function(e){e=(e=(e=this.removeLines(e)).replace("-----BEGIN ENCRYPTED PRIVATE KEY-----","")).replace("-----END ENCRYPTED PRIVATE KEY-----",""),e=this.base64ToArrayBuffer(e);var t={},r=this.arrayBufferToHexString(e);return t.data=r,t.data.includes(PBES2_OID)&&t.data.includes(PBKDF2_OID)&&(t.valid=!0),t.saltBegin=t.data.indexOf(PBKDF2_OID)+28,t.data.includes(AES256GCM_OID)?(t.cipher="AES-GCM",t.length=256,t.ivBegin=t.data.indexOf(AES256GCM_OID)+24):t.data.includes(AES192GCM_OID)?(t.cipher="AES-GCM",t.length=192,t.ivBegin=t.data.indexOf(AES192GCM_OID)+24):t.data.includes(AES128GCM_OID)?(t.cipher="AES-GCM",t.length=128,t.ivBegin=t.data.indexOf(AES128GCM_OID)+24):t.data.includes(AES256CBC_OID)?(t.cipher="AES-CBC",t.length=256,t.ivBegin=t.data.indexOf(AES256CBC_OID)+24):t.data.includes(AES192CBC_OID)?(t.cipher="AES-CBC",t.length=192,t.ivBegin=t.data.indexOf(AES192CBC_OID)+24):t.data.includes(AES128CBC_OID)?(t.cipher="AES-CBC",t.length=128,t.ivBegin=t.data.indexOf(AES128CBC_OID)+24):t.data.includes(AES256CFB_OID)?(t.cipher="AES-CFB",t.length=256,t.ivBegin=t.data.indexOf(AES256CFB_OID)+24):t.data.includes(AES192CFB_OID)?(t.cipher="AES-CFB",t.length=192,t.ivBegin=t.data.indexOf(AES192CFB_OID)+24):t.data.includes(AES128CFB_OID)&&(t.cipher="AES-CFB",t.length=128,t.ivBegin=t.data.indexOf(AES128CFB_OID)+22),t.data.includes(SHA512_OID)?t.hash="SHA-512":t.data.includes(SHA384_OID)?t.hash="SHA-384":t.data.includes(SHA256_OID)?t.hash="SHA-256":t.data.includes(SHA1_OID)&&(t.hash="SHA-1"),t.saltLength=parseInt(t.data.substr(t.saltBegin,2),16),t.ivLength=parseInt(t.data.substr(t.ivBegin,2),16),t.salt=t.data.substr(t.saltBegin+2,2*t.saltLength),t.iv=t.data.substr(t.ivBegin+2,2*t.ivLength),t.iterBegin=t.saltBegin+4+2*t.saltLength,t.iterLength=parseInt(t.data.substr(t.iterBegin,2),16),t.iter=parseInt(t.data.substr(t.iterBegin+2,2*t.iterLength),16),t.sequencePadding="81"===t.data.substr(2,2)?8:10,t.parametersPadding="81"===t.data.substr(2,2)?12:16,t.sequenceLength=parseInt(t.data.substr(t.sequencePadding,2),16),t.encryptedDataBegin=t.parametersPadding+2*t.sequenceLength,t.encryptedDataPadding="81"===t.data.substr(t.encryptedDataBegin-2,2)?2:4,t.encryptedDataLength=parseInt(t.data.substr(t.encryptedDataBegin,6),16),t.encryptedData=t.data.substr(t.encryptedDataBegin+t.encryptedDataPadding,2*t.encryptedDataLength),{salt:this.hexStringToArrayBuffer(t.salt),iv:this.hexStringToArrayBuffer(t.iv),cipher:t.cipher,length:t.length,hash:t.hash,iter:t.iter,encryptedData:this.hexStringToArrayBuffer(t.encryptedData)}}},{key:"cryptoPrivateToPem",value:function(e){var n=this;return new Promise(function(o,t){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input to be a CryptoKey Object");cryptoApi.exportKey("pkcs8",e).then(function(e){var t=n.arrayBufferToBase64(e),r=n.addNewLines(t);o(r="-----BEGIN PRIVATE KEY-----\r\n"+r+"-----END PRIVATE KEY-----")}).catch(function(e){t(e)})})}},{key:"pemPrivateToCrypto",value:function(p,s){var c=this;return void 0===s&&(s={}),s.isExtractable=void 0===s.isExtractable||s.isExtractable,new Promise(function(t,r){if("string"!=typeof p)throw new TypeError("Expected input of pem to be a String");if("boolean"!=typeof s.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");p=(p=p.replace("-----BEGIN PRIVATE KEY-----","")).replace("-----END PRIVATE KEY-----","");var e=c.removeLines(p),o=c.base64ToArrayBuffer(e),n=c.arrayBufferToHexString(o),a={};if(n.includes(EC_OID)){if(s.name=void 0!==s.name?s.name:"ECDH","string"!=typeof s.name)throw new TypeError("Expected input of options.name to be a String");var i=null;if(n.includes(P256_OID)?i="P-256":n.includes(P384_OID)?i="P-384":n.includes(P521_OID)&&(i="P-521"),"ECDH"===s.name)s.usages=void 0!==s.usages?s.usages:["deriveKey","deriveBits"];else{if("ECDSA"!==s.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");s.usages=void 0!==s.usages?s.usages:["sign"]}if("object"!==_typeof(s.usages))throw new TypeError("Expected input of options.usages to be an Array");a.name=s.name,a.namedCurve=i}else{if(!n.includes(RSA_OID))throw new TypeError("Expected input of pem is not a valid private key");if(s.name=void 0!==s.name?s.name:"RSA-OAEP",s.hash=void 0!==s.hash?s.hash:"SHA-512","string"!=typeof s.name)throw new TypeError("Expected input of options.name to be a String");if("string"!=typeof s.hash)throw new TypeError("Expected input of options.hash to be a String");if("RSA-OAEP"===s.name)s.usages=void 0!==s.usages?s.usages:["decrypt","unwrapKey"];else{if("RSA-PSS"!==s.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");s.usages=void 0!==s.usages?s.usages:["sign"]}if("object"!==_typeof(s.usages))throw new TypeError("Expected input of options.usages to be an Array");a.name=s.name,a.hash={},a.hash.name=s.hash}cryptoApi.importKey("pkcs8",o,a,s.isExtractable,s.usages).then(function(e){t(e)}).catch(function(e){r(e)})})}},{key:"cryptoPublicToPem",value:function(e){var n=this;return new Promise(function(o,t){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object of type public");cryptoApi.exportKey("spki",e).then(function(e){var t=n.arrayBufferToBase64(e),r=n.addNewLines(t);o(r="-----BEGIN PUBLIC KEY-----\r\n"+r+"-----END PUBLIC KEY-----")}).catch(function(e){t(e)})})}},{key:"pemPublicToCrypto",value:function(p,s){var c=this;return void 0===s&&(s={}),s.isExtractable=void 0===s.isExtractable||s.isExtractable,new Promise(function(t,r){if("string"!=typeof p)throw new TypeError("Expected input of pem to be a String");if("boolean"!=typeof s.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");p=(p=p.replace("-----BEGIN PUBLIC KEY-----","")).replace("-----END PUBLIC KEY-----","");var e=c.removeLines(p),o=c.base64ToArrayBuffer(e),n=c.arrayBufferToHexString(o),a={};if(n.includes(EC_OID)){if(s.name=void 0!==s.name?s.name:"ECDH","string"!=typeof s.name)throw new TypeError("Expected input of options.name to be a String");var i=null;if(n.includes(P256_OID)?i="P-256":n.includes(P384_OID)?i="P-384":n.includes(P521_OID)&&(i="P-521"),"ECDH"===s.name)s.usages=void 0!==s.usages?s.usages:[];else{if("ECDSA"!==s.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");s.usages=void 0!==s.usages?s.usages:["verify"]}if("object"!==_typeof(s.usages))throw new TypeError("Expected input of options.usages to be an Array");a.name=s.name,a.namedCurve=i}else{if(!n.includes(RSA_OID))throw new TypeError("Expected input of pem is not a valid public key");if(s.name=void 0!==s.name?s.name:"RSA-OAEP",s.hash=void 0!==s.hash?s.hash:"SHA-512","string"!=typeof s.name)throw new TypeError("Expected input of options.name to be a String");if("string"!=typeof s.hash)throw new TypeError("Expected input of options.hash to be a String");if("RSA-OAEP"===s.name)s.usages=void 0!==s.usages?s.usages:["encrypt","wrapKey"];else{if("RSA-PSS"!==s.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");s.usages=void 0!==s.usages?s.usages:["verify"]}if("object"!==_typeof(s.usages))throw new TypeError("Expected input of options.usages to be an Array");a.name=s.name,a.hash={},a.hash.name=s.hash}cryptoApi.importKey("spki",o,a,s.isExtractable,s.usages).then(function(e){t(e)}).catch(function(e){r(e)})})}},{key:"cryptoToBase64",value:function(e,o){var n=this,a=null;switch(e.type){case"secret":a="raw";break;case"private":a="pkcs8";break;case"public":a="spki"}return o=void 0!==o?o:a,new Promise(function(r,t){if("[object CryptoKey]"!==Object.prototype.toString.call(e))throw new TypeError("Expected input of key to be a CryptoKey Object");if("string"!=typeof o)throw new TypeError("Expected input of type to be a String");cryptoApi.exportKey(a,e).then(function(e){var t=n.arrayBufferToBase64(e);r(t)}).catch(function(e){t(e)})})}},{key:"base64ToCrypto",value:function(n,a){var i=this;return void 0===a&&(a={}),a.name=void 0!==a.name?a.name:"AES-GCM",a.isExtractable=void 0===a.isExtractable||a.isExtractable,new Promise(function(t,r){if("string"!=typeof n)throw new TypeError("Expected input of key to be a Base64 String");if("string"!=typeof a.name)throw new TypeError("Expected input of options.name to be a String");if("boolean"!=typeof a.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");var e={};if(e.name=a.name,"AES-GCM"===a.name||"AES-CBC"===a.name){if(a.type=void 0!==a.type?a.type:"raw",a.length=void 0!==a.length?a.length:256,a.usages=void 0!==a.usages?a.usages:["encrypt","decrypt","wrapKey","unwrapKey"],"number"!=typeof a.length)throw new TypeError("Expected input of options.length to be a Number")}else if("ECDH"===a.name){if(a.type=void 0!==a.type?a.type:"pkcs8",a.namedCurve=void 0!==a.namedCurve?a.namedCurve:"P-256",a.usages=void 0!==a.usages?a.usages:["deriveKey","deriveBits"],"string"!=typeof a.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");e.namedCurve=a.namedCurve}else if("ECDSA"===a.name){if(a.type=void 0!==a.type?a.type:"pkcs8",a.namedCurve=void 0!==a.namedCurve?a.namedCurve:"P-256",a.usages=void 0!==a.usages?a.usages:["sign"],"string"!=typeof a.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");e.namedCurve=a.namedCurve}else if("RSA-OAEP"===a.name){if(a.type=void 0!==a.type?a.type:"pkcs8",a.hash=void 0!==a.hash?a.hash:"SHA-512",a.usages=void 0!==a.usages?a.usages:["decrypt","unwrapKey"],"string"!=typeof a.hash)throw new TypeError("Expected input of options.hash to be a String");e.hash={},e.hash.name=a.hash}else{if("RSA-PSS"!==a.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");if(a.type=void 0!==a.type?a.type:"pkcs8",a.hash=void 0!==a.hash?a.hash:"SHA-512",a.usages=void 0!==a.usages?a.usages:["sign"],"string"!=typeof a.hash)throw new TypeError("Expected input of options.hash to be a String");e.hash={},e.hash.name=a.hash}if("string"!=typeof a.type)throw new TypeError("Expected input of options.type to be a String");if("object"!==_typeof(a.usages))throw new TypeError("Expected input of options.usages to be an Array");var o=i.base64ToArrayBuffer(n);cryptoApi.importKey(a.type,o,e,a.isExtractable,a.usages).then(function(e){t(e)}).catch(function(e){r(e)})})}},{key:"getRSAKeyPair",value:function(e,o,n,a,i){return e=void 0!==e?e:2048,o=void 0!==o?o:"SHA-512",n=void 0!==n?n:"RSA-OAEP",i=void 0===i||i,new Promise(function(t,r){if("number"!=typeof e)throw new TypeError("Expected input of modulusLength to be a Number");if("string"!=typeof o)throw new TypeError("Expected input of hash expected to be a String");if("string"!=typeof n)throw new TypeError("Expected input of paddingScheme to be a String");if("boolean"!=typeof i)throw new TypeError("Expected input of isExtractable to be a Boolean");if("RSA-OAEP"===n)a=void 0!==a?a:["encrypt","decrypt","wrapKey","unwrapKey"];else{if("RSA-PSS"!==n)throw new TypeError("Expected input of paddingScheme is not a valid padding scheme");a=void 0!==a?a:["sign","verify"]}if("object"!==_typeof(a))throw new TypeError("Expected input of usages to be an Array");cryptoApi.generateKey({name:n,modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:o}},i,a).then(function(e){t(e)}).catch(function(e){r(e)})})}},{key:"rsaEncrypt",value:function(e,o){var n=this;return new Promise(function(r,t){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"public"!==e.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object of type public");if("object"!==_typeof(o))throw new TypeError("Expected input of data to be an ArrayBuffer");cryptoApi.encrypt({name:"RSA-OAEP"},e,o).then(function(e){var t=n.arrayBufferToBase64(e);r(t)}).catch(function(e){t(e)})})}},{key:"rsaDecrypt",value:function(o,n){var a=this;return new Promise(function(t,r){if("[object CryptoKey]"!==Object.prototype.toString.call(o)&&"private"!==o.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object of type private");if("string"!=typeof n)throw new TypeError("Expected input of encryptedData to be a Base64 String");var e=a.base64ToArrayBuffer(n);cryptoApi.decrypt({name:"RSA-OAEP"},o,e).then(function(e){t(e)}).catch(function(e){r(e)})})}},{key:"getECKeyPair",value:function(e,o,n,a){return e=void 0!==e?e:"P-256",o=void 0!==o?o:"ECDH",a=void 0===a||a,new Promise(function(t,r){if("string"!=typeof e)throw new TypeError("Expected input of curve to be a String");if("string"!=typeof o)throw new TypeError("Expected input of type to be a String");if("boolean"!=typeof a)throw new TypeError("Expected input of isExtractable to be a Boolean");if("ECDH"===o)n=void 0!==n?n:["deriveKey","deriveBits"];else{if("ECDSA"!==o)throw new TypeError("Expected input of type is not a valid algorithm type");n=void 0!==n?n:["sign","verify"]}if("object"!==_typeof(n))throw new TypeError("Expected input of usages to be an Array");cryptoApi.generateKey({name:o,namedCurve:e},a,n).then(function(e){t(e)}).catch(function(e){r(e)})})}},{key:"getPublicKey",value:function(n,a){return void 0===a&&(a={}),a.isExtractable=void 0===a.isExtractable||a.isExtractable,new Promise(function(r,o){if("[object CryptoKey]"!==Object.prototype.toString.call(n)&&"private"!==n.type)throw new TypeError("Expected input of privateKey must be a CryptoKey Object of type private");if("boolean"!=typeof a.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");cryptoApi.exportKey("jwk",n).then(function(e){var t={};switch(t.name=n.algorithm.name,n.algorithm.name){case"ECDH":if(delete e.d,e.key_ops=[],a.usages=void 0!==a.usages?a.usages:[],"object"!==_typeof(a.usages))throw new TypeError("Expected input of options.usages to be an Array");t.namedCurve=n.algorithm.namedCurve;break;case"ECDSA":if(delete e.d,e.key_ops=["verify"],a.usages=void 0!==a.usages?a.usages:["verify"],"object"!==_typeof(a.usages))throw new TypeError("Expected input of options.usages to be an Array");t.namedCurve=n.algorithm.namedCurve;break;case"RSA-OAEP":if(delete e.d,delete e.dp,delete e.dq,delete e.p,delete e.q,delete e.qi,e.key_ops=["encrypt","wrapKey"],a.usages=void 0!==a.usages?a.usages:["encrypt","wrapKey"],"object"!==_typeof(a.usages))throw new TypeError("Expected input of options.usages to be an Array");t.hash={},t.hash.name=n.algorithm.hash.name;break;case"RSA-PSS":if(delete e.d,delete e.dp,delete e.dq,delete e.p,delete e.q,delete e.qi,e.key_ops=["verify"],a.usages=void 0!==a.usages?a.usages:["verify"],"object"!==_typeof(a.usages))throw new TypeError("Expected input of options.usages to be an Array");t.hash={},t.hash.name=n.algorithm.hash.name;break;default:throw new TypeError("Expected input of privateKey is not a valid private key")}cryptoApi.importKey("jwk",e,t,a.isExtractable,a.usages).then(function(e){r(e)}).catch(function(e){o(e)})}).catch(function(e){o(e)})})}},{key:"encryptPrivateKey",value:function(i,p,s,c,f,y){var u=this;return s=void 0!==s?s:64e3,c=void 0!==c?c:"SHA-512",f=void 0!==f?f:"AES-GCM",y=void 0!==y?y:256,new Promise(function(r,t){if("[object CryptoKey]"!==Object.prototype.toString.call(i)&&"private"!==i.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object of type private");if("string"!=typeof p)throw new TypeError("Expected input of passphrase to be a String");if("number"!=typeof s)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof c)throw new TypeError("Expected input of hash to be a String");if("string"!=typeof f)throw new TypeError("Expected input of cipher to be a String");if("number"!=typeof y)throw new TypeError("Expected input of length to be a Number");var e=null;switch(f){case"AES-GCM":e=12;break;case"AES-CBC":case"AES-CFB":e=16}var o=cryptoLib.getRandomValues(new Uint8Array(16)),n=cryptoLib.getRandomValues(new Uint8Array(e)),a=u.stringToArrayBuffer(p);cryptoApi.importKey("raw",a,{name:"PBKDF2"},!1,["deriveKey"]).then(function(e){cryptoApi.deriveKey({name:"PBKDF2",salt:o,iterations:s,hash:c},e,{name:f,length:y},!1,["wrapKey"]).then(function(e){cryptoApi.wrapKey("pkcs8",i,e,{name:f,iv:n,tagLength:128}).then(function(e){var t=u.toAsn1(e,o,n,s,c,f,y);r(t)}).catch(function(e){t(e)})}).catch(function(e){t(e)})}).catch(function(e){t(e)})})}},{key:"decryptPrivateKey",value:function(a,i,p){var s=this,c=this;return void 0===p&&(p={}),p.name=void 0!==p.name?p.name:"ECDH",p.isExtractable=void 0===p.isExtractable||p.isExtractable,new Promise(function(t,r){if("string"!=typeof a)throw new TypeError("Expected input of encryptedPrivateKey to be a Base64 String");if("string"!=typeof i)throw new TypeError("Expected input of passphrase to be a String");if("boolean"!=typeof p.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");var o=s.fromAsn1(a),n={};if(n.name=p.name,"ECDH"===p.name){if(p.namedCurve=void 0!==p.namedCurve?p.namedCurve:"P-256",p.usages=void 0!==p.usages?p.usages:["deriveKey","deriveBits"],"string"!=typeof p.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");if("object"!==_typeof(p.usages))throw new TypeError("Expected input of options.usages to be an Array");n.namedCurve=p.namedCurve}else if("ECDSA"===p.name){if(p.namedCurve=void 0!==p.namedCurve?p.namedCurve:"P-256",p.usages=void 0!==p.usages?p.usages:["sign"],"string"!=typeof p.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");if("object"!==_typeof(p.usages))throw new TypeError("Expected input of options.usages to be an Array");n.namedCurve=p.namedCurve}else if("RSA-OAEP"===p.name){if(p.hash=void 0!==p.hash?p.hash:"SHA-512",p.usages=void 0!==p.usages?p.usages:["decrypt","unwrapKey"],"string"!=typeof p.hash)throw new TypeError("Expected input of options.hash to be a String");if("object"!==_typeof(p.usages))throw new TypeError("Expected input of options.usages to be an Array");n.hash={},n.hash.name=p.hash}else{if("RSA-PSS"!==p.name)throw new TypeError("Expected input of encryptedPrivateKey is not a valid encrypted private key");if(p.hash=void 0!==p.hash?p.hash:"SHA-512",p.usages=void 0!==p.usages?p.usages:["sign"],"string"!=typeof p.hash)throw new TypeError("Expected input of options.hash to be a String");if("object"!==_typeof(p.usages))throw new TypeError("Expected input of options.usages to be an Array");n.hash={},n.hash.name=p.hash}var e=c.stringToArrayBuffer(i);cryptoApi.importKey("raw",e,{name:"PBKDF2"},!1,["deriveKey"]).then(function(e){cryptoApi.deriveKey({name:"PBKDF2",salt:o.salt,iterations:o.iter,hash:o.hash},e,{name:o.cipher,length:o.length},!1,["unwrapKey"]).then(function(e){cryptoApi.unwrapKey("pkcs8",o.encryptedData,e,{name:o.cipher,iv:o.iv,tagLength:128},n,p.isExtractable,p.usages).then(function(e){t(e)}).catch(function(e){r(e)})}).catch(function(e){r(e)})}).catch(function(e){r(e)})})}},{key:"keyAgreement",value:function(e,o,n){return void 0===n&&(n={}),n.bitLength=void 0!==n.bitLength?n.bitLength:256,n.hkdfHash=void 0!==n.hkdfHash?n.hkdfHash:"SHA-512",n.hkdfSalt=void 0!==n.hkdfSalt?n.hkdfSalt:new Uint8Array,n.hkdfInfo=void 0!==n.hkdfInfo?n.hkdfInfo:new Uint8Array,n.cipher=void 0!==n.cipher?n.cipher:"AES-GCM",n.length=void 0!==n.length?n.length:256,n.usages=void 0!==n.usages?n.usages:["encrypt","decrypt","unwrapKey","wrapKey"],n.isExtractable=void 0===n.isExtractable||n.isExtractable,new Promise(function(t,r){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object of type private");if("[object CryptoKey]"!==Object.prototype.toString.call(o)&&"public"!==o.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object of type public");if("number"!=typeof n.bitLength)throw new TypeError("Expected input of options.bitLength to be a Number");if("string"!=typeof n.hkdfHash)throw new TypeError("Expected input of options.hkdfHash to be a String");if("object"!==_typeof(n.hkdfSalt))throw new TypeError("Expected input of options.hkdfSalt to be an ArrayBuffer");if("object"!==_typeof(n.hkdfInfo))throw new TypeError("Expected input of options.hkdfInfo to be an ArrayBuffer");if("string"!=typeof n.cipher)throw new TypeError("Expected input of options.cipher to be a String");if("number"!=typeof n.length)throw new TypeError("Expected input of options.length to be a Number");if("object"!==_typeof(n.usages))throw new TypeError("Expected input of options.usages to be an Array");if("boolean"!=typeof n.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");cryptoApi.deriveBits({name:"ECDH",namedCurve:o.algorithm.namedCurve,public:o},e,n.bitLength).then(function(e){cryptoApi.importKey("raw",e,{name:"HKDF"},!1,["deriveKey"]).then(function(e){cryptoApi.deriveKey({name:"HKDF",hash:{name:n.hkdfHash},salt:n.hkdfSalt,info:n.hkdfInfo},e,{name:n.cipher,length:n.length},n.isExtractable,n.usages).then(function(e){t(e)}).catch(function(e){r(e)})}).catch(function(e){r(e)})}).catch(function(e){r(e)})})}},{key:"getSharedKey",value:function(e,o){return e=void 0!==e?e:256,void 0===o&&(o={}),o.cipher=void 0!==o.cipher?o.cipher:"AES-GCM",o.usages=void 0!==o.usages?o.usages:["encrypt","decrypt","wrapKey","unwrapKey"],o.isExtractable=void 0===o.isExtractable||o.isExtractable,new Promise(function(t,r){if("number"!=typeof e)throw new TypeError("Expected input of length to be a Number");if("string"!=typeof o.cipher)throw new TypeError("Expected input of options.cipher expected to be a String");if("object"!==_typeof(o.usages))throw new TypeError("Expected input of options.usages to be an Array");if("boolean"!=typeof o.isExtractable)throw new TypeError("Expected input of options.isExtractable expected to be a Boolean");cryptoApi.generateKey({name:o.cipher,length:e},o.isExtractable,o.usages).then(function(e){t(e)}).catch(function(e){r(e)})})}},{key:"encryptKey",value:function(n,a){var i=this;return new Promise(function(r,t){if("[object CryptoKey]"!==Object.prototype.toString.call(n))throw new TypeError("Expected input of wrappingKey to be a CryptoKey Object");if("[object CryptoKey]"!==Object.prototype.toString.call(a))throw new TypeError("Expected input of key to be a CryptoKey Object");var e=null;switch(a.type){case"secret":e="raw";break;case"private":e="pkcs8";break;case"public":e="spki"}if("secret"===n.type){var o=null;if("AES-GCM"===n.algorithm.name)o=cryptoLib.getRandomValues(new Uint8Array(12));else{if("AES-CBC"!==n.algorithm.name)throw new TypeError("Cipher mode of the wrappingKey is not supported");o=cryptoLib.getRandomValues(new Uint8Array(16))}cryptoApi.wrapKey(e,a,n,{name:n.algorithm.name,iv:o,tagLength:128}).then(function(e){var t=i.arrayBufferToBase64(o)+i.arrayBufferToBase64(e);r(t)}).catch(function(e){t(e)})}else{if("RSA-OAEP"!==n.algorithm.name)throw new TypeError("Expected input of wrappingKey is not a supported key");if("public"!==n.type)throw new TypeError("Expected input of wrappingKey to be a CryptoKey Object of type public");cryptoApi.wrapKey(e,a,n,{name:"RSA-OAEP",hash:{name:n.algorithm.hash.name}}).then(function(e){var t=i.arrayBufferToBase64(e);r(t)}).catch(function(e){t(e)})}})}},{key:"decryptKey",value:function(s,c,f){var y=this;return void 0===f&&(f={}),f.name=void 0!==f.name?f.name:"AES-GCM",f.isExtractable=void 0===f.isExtractable||f.isExtractable,new Promise(function(t,r){if("[object CryptoKey]"!==Object.prototype.toString.call(s))throw new TypeError("Expected input of unwrappingKey to be a CryptoKey Object");if("string"!=typeof c)throw new TypeError("Expected input of encryptedKey to be a Base64 String");if("string"!=typeof f.name)throw new TypeError("Expected input of options.name to be a String");if("boolean"!=typeof f.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");var e={};if(e.name=f.name,"AES-GCM"===f.name||"AES-CBC"===f.name){if(f.type=void 0!==f.type?f.type:"raw",f.length=void 0!==f.length?f.length:256,f.usages=void 0!==f.usages?f.usages:["encrypt","decrypt","wrapKey","unwrapKey"],"number"!=typeof f.length)throw new TypeError("Expected input of options.length to be a Number")}else if("ECDH"===f.name){if(f.type=void 0!==f.type?f.type:"pkcs8",f.namedCurve=void 0!==f.namedCurve?f.namedCurve:"P-256",f.usages=void 0!==f.usages?f.usages:["deriveKey","deriveBits"],"string"!=typeof f.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");e.namedCurve=f.namedCurve}else if("ECDSA"===f.name){if(f.type=void 0!==f.type?f.type:"pkcs8",f.namedCurve=void 0!==f.namedCurve?f.namedCurve:"P-256",f.usages=void 0!==f.usages?f.usages:["sign"],"string"!=typeof f.namedCurve)throw new TypeError("Expected input of options.namedCurve to be a String");e.namedCurve=f.namedCurve}else if("RSA-OAEP"===f.name){if(f.type=void 0!==f.type?f.type:"pkcs8",f.hash=void 0!==f.hash?f.hash:"SHA-512",f.usages=void 0!==f.usages?f.usages:["decrypt","unwrapKey"],"string"!=typeof f.hash)throw new TypeError("Expected input of options.hash to be a String");e.hash={},e.hash.name=f.hash}else{if("RSA-PSS"!==f.name)throw new TypeError("Expected input of options.name is not a valid algorithm name");if(f.type=void 0!==f.type?f.type:"pkcs8",f.hash=void 0!==f.hash?f.hash:"SHA-512",f.usages=void 0!==f.usages?f.usages:["sign"],"string"!=typeof f.hash)throw new TypeError("Expected input of options.hash to be a String");e.hash={},e.hash.name=f.hash}if("string"!=typeof f.type)throw new TypeError("Expected input of options.type to be a String");if("object"!==_typeof(f.usages))throw new TypeError("Expected input of options.usages to be an Array");if("secret"===s.type){var o=null,n=null;if("AES-GCM"===s.algorithm.name)o=c.substring(0,16),n=c.substring(16);else{if("AES-CBC"!==s.algorithm.name)throw new TypeError("Cipher mode of the wrappingKey is not supported");o=c.substring(0,24),n=c.substring(24)}var a=y.base64ToArrayBuffer(o),i=y.base64ToArrayBuffer(n);cryptoApi.unwrapKey(f.type,i,s,{name:s.algorithm.name,iv:a,tagLength:128},e,f.isExtractable,f.usages).then(function(e){t(e)}).catch(function(e){r(e)})}else{if("RSA-OAEP"!==s.algorithm.name)throw new TypeError("Expected input of unwrappingKey is not a supported key");if("private"!==s.type)throw new TypeError("Expected input of unwrappingKey to be a CryptoKey Object of type private");var p=y.base64ToArrayBuffer(c);cryptoApi.unwrapKey(f.type,p,s,{name:"RSA-OAEP",modulusLength:s.algorithm.modulusLength,publicExponent:new Uint8Array([1,0,1]),hash:{name:s.algorithm.hash.name}},e,f.isExtractable,f.usages).then(function(e){t(e)}).catch(function(e){r(e)})}})}},{key:"signKey",value:function(o,e,n){var a=this;return void 0===n&&(n={}),new Promise(function(r,t){if("[object CryptoKey]"!==Object.prototype.toString.call(o)&&"private"!==o.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object of type private");if("[object CryptoKey]"!==Object.prototype.toString.call(e))throw new TypeError("Expected input of key to be a CryptoKey Object");cryptoApi.exportKey("raw",e).then(function(e){if("ECDSA"===o.algorithm.name){if(n.hash=void 0!==n.hash?n.hash:"SHA-512","string"!=typeof n.hash)throw new TypeError("Expected input of options.hash to be a String");cryptoApi.sign({name:"ECDSA",hash:{name:n.hash}},o,e).then(function(e){var t=a.arrayBufferToBase64(e);r(t)}).catch(function(e){t(e)})}else{if("RSA-PSS"!==o.algorithm.name)throw new TypeError("Expected input of privateKey is not a valid private key");if(n.saltLength=void 0!==n.saltLength?n.saltLength:128,"number"!=typeof n.saltLength)throw new TypeError("Expected input of options.saltLength to be a Number");cryptoApi.sign({name:"RSA-PSS",saltLength:n.saltLength},o,e).then(function(e){var t=a.arrayBufferToBase64(e);r(t)}).catch(function(e){t(e)})}}).catch(function(e){t(e)})})}},{key:"verifyKey",value:function(n,e,a,i){var p=this;return void 0===i&&(i={}),new Promise(function(t,r){if("[object CryptoKey]"!==Object.prototype.toString.call(n)&&"public"!==n.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object of type public");if("[object CryptoKey]"!==Object.prototype.toString.call(e))throw new TypeError("Expected input of key to be a CryptoKey Object");if("string"!=typeof a)throw new TypeError("Expected input of signature to be a Base64 String");var o=p.base64ToArrayBuffer(a);cryptoApi.exportKey("raw",e).then(function(e){if("ECDSA"===n.algorithm.name){if(i.hash=void 0!==i.hash?i.hash:"SHA-512","string"!=typeof i.hash)throw new TypeError("Expected input of options.hash to be a String");cryptoApi.verify({name:"ECDSA",hash:{name:i.hash}},n,o,e).then(function(e){t(e)}).catch(function(e){r(e)})}else{if("RSA-PSS"!==n.algorithm.name)throw new TypeError("Expected input of publicKey is not a valid public key");cryptoApi.verify({name:"RSA-PSS",saltLength:128},n,o,e).then(function(e){t(e)}).catch(function(e){r(e)})}}).catch(function(e){r(e)})})}},{key:"sign",value:function(e,o,n){var a=this;return void 0===n&&(n={}),new Promise(function(r,t){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"private"!==e.type)throw new TypeError("Expected input of privateKey to be a CryptoKey Object of type private");if("object"!==_typeof(o))throw new TypeError("Expected input of data to be an ArrayBuffer");if("ECDSA"===e.algorithm.name){if(n.hash=void 0!==n.hash?n.hash:"SHA-512","string"!=typeof n.hash)throw new TypeError("Expected input of options.hash to be a String");cryptoApi.sign({name:"ECDSA",hash:{name:n.hash}},e,o).then(function(e){var t=a.arrayBufferToBase64(e);r(t)}).catch(function(e){t(e)})}else{if("RSA-PSS"!==e.algorithm.name)throw new TypeError("Expected input of privateKey is not a valid private key");if(n.saltLength=void 0!==n.saltLength?n.saltLength:128,"number"!=typeof n.saltLength)throw new TypeError("Expected input of options.saltLength to be a Number");cryptoApi.sign({name:"RSA-PSS",saltLength:n.saltLength},e,o).then(function(e){var t=a.arrayBufferToBase64(e);r(t)}).catch(function(e){t(e)})}})}},{key:"verify",value:function(o,n,a,i){var p=this;return void 0===i&&(i={}),new Promise(function(t,r){if("[object CryptoKey]"!==Object.prototype.toString.call(o)&&"public"!==o.type)throw new TypeError("Expected input of publicKey to be a CryptoKey Object of type public");if("object"!==_typeof(n))throw new TypeError("Expected input of data to be an ArrayBuffer");if("string"!=typeof a)throw new TypeError("Expected input of signature to be a Base64 String");var e=p.base64ToArrayBuffer(a);if("ECDSA"===o.algorithm.name){if(i.hash=void 0!==i.hash?i.hash:"SHA-512","string"!=typeof i.hash)throw new TypeError("Expected input of options.hash to be a String");cryptoApi.verify({name:"ECDSA",hash:{name:i.hash}},o,e,n).then(function(e){t(e)}).catch(function(e){r(e)})}else{if("RSA-PSS"!==o.algorithm.name)throw new TypeError("Expected input of publicKey is not a valid public key");cryptoApi.verify({name:"RSA-PSS",saltLength:128},o,e,n).then(function(e){t(e)}).catch(function(e){r(e)})}})}},{key:"encrypt",value:function(e,r){var a=this;return new Promise(function(o,t){if("[object CryptoKey]"!==Object.prototype.toString.call(e)&&"secret"!==e.type)throw new TypeError("Expected input of sharedKey to be a CryptoKey Object");if("object"!==_typeof(r))throw new TypeError("Expected input of data to be an ArrayBuffer");var n=null;if("AES-GCM"===e.algorithm.name)n=cryptoLib.getRandomValues(new Uint8Array(12));else{if("AES-CBC"!==e.algorithm.name)throw new TypeError("Cipher mode of the sharedKey is not supported");n=cryptoLib.getRandomValues(new Uint8Array(16))}cryptoApi.encrypt({name:e.algorithm.name,iv:n,tagLength:128},e,r).then(function(e){var t=a.arrayBufferToBase64(n),r=a.arrayBufferToBase64(e);o(t+r)}).catch(function(e){t(e)})})}},{key:"decrypt",value:function(i,p,s){var c=this;return void 0===s&&(s={}),s.cipher=void 0!==s.cipher?s.cipher:"AES-GCM",new Promise(function(t,r){if("[object CryptoKey]"!==Object.prototype.toString.call(i)&&"secret"!==i.type)throw new TypeError("Expected input of sharedKey to be a CryptoKey Object");if("string"!=typeof p)throw new TypeError("Expected input of encryptedData to be a String");if("string"!=typeof s.cipher)throw new TypeError("Expected input of options.cipher to be a String");var e=null,o=null;if("AES-GCM"===s.cipher)e=p.substring(0,16),o=p.substring(16);else{if("AES-CBC"!==s.cipher)throw new TypeError("Cipher mode of the sharedKey is not supported");e=p.substring(0,24),o=p.substring(24)}var n=c.base64ToArrayBuffer(e),a=c.base64ToArrayBuffer(o);cryptoApi.decrypt({name:s.cipher,iv:n,tagLength:128},i,a).then(function(e){t(e)}).catch(function(e){r(e)})})}},{key:"derivePassphraseKey",value:function(o,n,a,i){var p=this;return a=void 0!==a?a:64e3,void 0===i&&(i={}),i.hash=void 0!==i.hash?i.hash:"SHA-512",i.length=void 0!==i.length?i.length:256,i.cipher=void 0!==i.cipher?i.cipher:"AES-GCM",i.usages=void 0!==i.usages?i.usages:["encrypt","decrypt","wrapKey","unwrapKey"],i.isExtractable=void 0===i.isExtractable||i.isExtractable,new Promise(function(t,r){if("string"!=typeof o)throw new TypeError("Expected input of passphrase to be a String");if("object"!==_typeof(n))throw new TypeError("Expected input of salt to be an ArrayBuffer");if("number"!=typeof a)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof i.hash)throw new TypeError("Expected input of options.hash to be a String");if("number"!=typeof i.length)throw new TypeError("Expected input of options.length to be a Number");if("string"!=typeof i.cipher)throw new TypeError("Expected input of options.cipher to be a String");if("object"!==_typeof(i.usages))throw new TypeError("Expected input of options.usages to be an Array");if("boolean"!=typeof i.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");var e=p.stringToArrayBuffer(o);cryptoApi.importKey("raw",e,{name:"PBKDF2"},!1,["deriveKey"]).then(function(e){cryptoApi.deriveKey({name:"PBKDF2",salt:n,iterations:a,hash:{name:i.hash}},e,{name:i.cipher,length:i.length},i.isExtractable,i.usages).then(function(e){t(e)}).catch(function(e){r(e)})}).catch(function(e){r(e)})})}},{key:"hashPassphrase",value:function(e,o,n,a){var i=this;return n=void 0!==n?n:64e3,void 0===a&&(a={}),a.hash=void 0!==a.hash?a.hash:"SHA-512",a.length=void 0!==a.length?a.length:256,a.cipher=void 0!==a.cipher?a.cipher:"AES-GCM",a.usages=void 0!==a.usages?a.usages:["encrypt","decrypt","wrapKey","unwrapKey"],a.isExtractable=void 0===a.isExtractable||a.isExtractable,new Promise(function(r,t){if("string"!=typeof e)throw new TypeError("Expected input of passphrase to be a String");if("object"!==_typeof(o))throw new TypeError("Expected input of salt to be an ArrayBuffer");if("number"!=typeof n)throw new TypeError("Expected input of iterations to be a Number");if("string"!=typeof a.hash)throw new TypeError("Expected input of options.hash to be a String");if("number"!=typeof a.length)throw new TypeError("Expected input of options.length to be a Number");if("string"!=typeof a.cipher)throw new TypeError("Expected input of options.cipher to be a String");if("object"!==_typeof(a.usages))throw new TypeError("Expected input of options.usages to be an Array");if("boolean"!=typeof a.isExtractable)throw new TypeError("Expected input of options.isExtractable to be a Boolean");i.derivePassphraseKey(e,o,n,a).then(function(e){cryptoApi.exportKey("raw",e).then(function(e){var t=i.arrayBufferToHexString(e);r(t)}).catch(function(e){t(e)})}).catch(function(e){t(e)})})}},{key:"getFingerprint",value:function(o,n){var a=this;return void 0===n&&(n={}),n.hash="undefined"!=typeof hash?hash:"SHA-512",n.isBuffer=void 0!==n.isBuffer&&n.isBuffer,new Promise(function(r,t){if("[object CryptoKey]"!==Object.prototype.toString.call(o))throw new TypeError("Expected input of key to be a CryptoKey Object");if("string"!=typeof n.hash)throw new TypeError("Expected input of options.hash to be a String");if("boolean"!=typeof n.isBuffer)throw new TypeError("Expected input of options.isBuffer to be a Boolean");var e=null;switch(o.type){case"secret":e="raw";break;case"private":e="pkcs8";break;case"public":e="spki"}cryptoApi.exportKey(e,o).then(function(e){cryptoApi.digest({name:n.hash},e).then(function(e){var t;n.isBuffer?r(e):(t=a.arrayBufferToHexString(e),r(t))}).catch(function(e){t(e)})}).catch(function(e){t(e)})})}},{key:"getRandomBytes",value:function(r){return r=void 0!==r?r:16,new Promise(function(e,t){if("number"!=typeof r)throw new TypeError("Expected input of size to be a Number");e(cryptoLib.getRandomValues(new Uint8Array(r)))})}}]),t}();